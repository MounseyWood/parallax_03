<!DOCTYPE html>
<html>
<head>
    <title>AR Parallax</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ar.js/2.2.2/aframe-ar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.2.0/aframe.min.js"></script>
    <style>
        .a-enter-vr-button {
            display: none;
        }
        #arjsDebugUIContainer {
            display: none;
        }
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
        }
        .canvas {
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            will-change: transform;
        }
        .loading-screen {
            position: fixed;
            width: 100%;
            height: 100%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: 0.25s ease all;
        }
        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body style="margin: 0; overflow: hidden;">
    <div class="loading-screen" id="loading">Loading...</div>
    <div class="canvas-container">
        <canvas class="canvas" id="canvas"></canvas>
    </div>
    
    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;">
        <a-marker type="pattern" url="pattern-marker.patt">
            <a-entity id="parallax-container" position="0 0 0">
                <!-- This will be our trigger for the parallax effect -->
            </a-entity>
        </a-marker>
        <a-entity camera></a-entity>
    </a-scene>

    <script>
        // Original canvas and context setup
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const loadingScreen = document.getElementById('loading');
        let loadCounter = 0;

        // Layer images setup (keep your original image setup)
        const background = new Image();
        const didot = new Image();
        const shadow = new Image();
        const man = new Image();
        const headlines = new Image();
        const title = new Image();
        const frame = new Image();
        const gloss = new Image();

        // Layer configuration (keep your original layer configuration)
        const layerList = [
            { image: background, src: './images/layer_1_1.png', zIndex: -5, position: { x: 0, y: 0 }, blend: 0, opacity: 1 },
            { image: didot, src: './images/layer_2_1.png', zIndex: -4, position: { x: 0, y: 0 }, blend: 0, opacity: 1 },
            { image: shadow, src: './images/layer_3_1.png', zIndex: -3, position: { x: 0, y: 0 }, blend: 'multiply', opacity: 0.5 },
            { image: man, src: './images/layer_4_1.png', zIndex: -2, position: { x: 0, y: 0 }, blend: 0, opacity: 1 },
            { image: headlines, src: './images/layer_5_1.png', zIndex: -0.5, position: { x: 0, y: 0 }, blend: 0, opacity: 1 },
            { image: title, src: './images/layer_6_1.png', zIndex: -0.5, position: { x: 0, y: 0 }, blend: 0, opacity: 1 },
            { image: frame, src: './images/layer_7_1.png', zIndex: 0, position: { x: 0, y: 0 }, blend: 0, opacity: 1 },
            { image: gloss, src: './images/layer_8_1.png', zIndex: 0.5, position: { x: 0, y: 0 }, blend: 0, opacity: 1 }
        ];

        // Modified Motion Controller to use AR marker position
        class ARMotionController {
            constructor() {
                this.motion = { x: 0, y: 0 };
                this.marker = document.querySelector('a-marker');
                this.setupARListeners();
            }

            setupARListeners() {
                this.marker.addEventListener('markerFound', () => {
                    canvas.style.opacity = '1';
                });

                this.marker.addEventListener('markerLost', () => {
                    canvas.style.opacity = '0';
                });

                // Track marker rotation
                this.marker.addEventListener('object3dset', () => {
                    const markerRotation = this.marker.object3D.rotation;
                    this.motion.x = THREE.Math.radToDeg(markerRotation.x);
                    this.motion.y = THREE.Math.radToDeg(markerRotation.y);
                });
            }

            getMotion() {
                return {
                    x: this.motion.x * 1.5,
                    y: this.motion.y * 1.5
                };
            }

            resetMotion() {
                this.motion = { x: 0, y: 0 };
            }
        }

        // Initialize AR motion controller
        const motionController = new ARMotionController();

        // Modified canvas setup for AR
        function setupCanvas() {
            const baseImage = layerList[0].image;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            canvas.width = viewportWidth;
            canvas.height = viewportHeight;
        }

        // Modified draw function
        function drawCanvas() {
            context.clearRect(0, 0, canvas.width, canvas.height);

            const motion = motionController.getMotion();
            const rotateX = motion.y * -1.5;
            const rotateY = motion.x * 1.5;

            const transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            canvas.style.transform = transform;

            layerList.forEach(layer => {
                const offset = {
                    x: motion.x * layer.zIndex * 2,
                    y: motion.y * layer.zIndex * 2
                };

                context.globalCompositeOperation = layer.blend || 'normal';
                context.globalAlpha = layer.opacity;
                context.drawImage(
                    layer.image,
                    offset.x,
                    offset.y,
                    canvas.width,
                    canvas.height
                );
            });

            requestAnimationFrame(drawCanvas);
        }

        // Image loading
        layerList.forEach(layer => {
            layer.image.onload = () => {
                loadCounter++;
                if (loadCounter >= layerList.length) {
                    setupCanvas();
                    loadingScreen.classList.add('hidden');
                    requestAnimationFrame(drawCanvas);
                }
            };
            layer.image.src = layer.src;
        });

        // Handle window resize
        window.addEventListener('resize', setupCanvas);

        // Handle visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                motionController.resetMotion();
            }
        });
    </script>
</body>
</html>
